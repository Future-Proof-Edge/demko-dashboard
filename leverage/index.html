<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Leverage Curve — The Demko Method</title>
<meta name="description" content="Interactive visualization of compounding AI leverage — from 1x to 12,000x">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; color: #e5e5e5; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow-x: hidden; }
  #root { min-height: 100vh; display: flex; flex-direction: column; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;
const steps = [
  { label: "Free Chatbot", multiplier: 1, category: "baseline", description: "You sign up for ChatGPT. Ask it to fix an email. It does. You close the tab.", detail: "300 million people stop here. ~$75-$150/month equivalent value.", color: "#6b7280" },
  { label: "Paid Subscription", multiplier: 1.3, category: "foundation", description: "You pay $20/month. Better model. Longer context window. Faster responses.", detail: "You're now in the top 0.3% of AI users on earth. ~15-25M people.", color: "#4ade80" },
  { label: "Structured Prompting", multiplier: 1.8, category: "foundation", description: "You learn chain-of-thought. Role prompting. Few-shot examples. Your outputs get noticeably better.", detail: "Most 'power users' plateau here. They think this is the ceiling.", color: "#4ade80" },
  { label: "Projects & Instructions", multiplier: 2.5, category: "foundation", description: "Custom instructions persist. Projects hold context. AI remembers your preferences across conversations.", detail: "Your AI starts to feel personalized. But it still can't DO anything.", color: "#22c55e" },
  { label: "Persistent Memory", multiplier: 4, category: "foundation", description: "Memory compounds across sessions. Session 50 is smarter than session 1. Your history becomes an asset.", detail: "The AI now knows your clients, your patterns, your preferences. It learns.", color: "#22c55e" },
  { label: "Claude Code", multiplier: 7, category: "system", description: "The AI doesn't just think — it writes code, creates files, deploys software. It can BUILD things.", detail: "This is the 0.04% red dot. ~2-5M people on earth. The chart ends here for everyone else.", color: "#ef4444" },
  { label: "Multi-Surface Routing", multiplier: 12, category: "architecture", description: "Desktop for strategy. Code terminal for engineering. Mobile for capture. Three surfaces, one unified system.", detail: "Each surface optimized for what it does best. Strategy flows to execution automatically.", color: "#f97316" },
  { label: "Master Protocol (CLAUDE.md)", multiplier: 20, category: "architecture", description: "A governing protocol file that controls how every session operates. Constraints. Frameworks. Quality standards.", detail: "The AI doesn't freelance anymore. It operates within a system designed through 18 months of iteration.", color: "#f97316" },
  { label: "Handoff Protocol (TASKS.md)", multiplier: 32, category: "architecture", description: "Strategy outputs become engineering inputs automatically. No translation layer. No context loss between surfaces.", detail: "Think on desktop → tasks queue → Claude Code builds. Seamless.", color: "#f97316" },
  { label: "MCP Connectors", multiplier: 55, category: "hands", description: "Google Drive. Gmail. GitHub. Notion. The AI can now READ and WRITE to your real tools. It has hands.", detail: "The brain is no longer in a jar. It can search your Drive, read your email, push code.", color: "#a855f7" },
  { label: "n8n Automation", multiplier: 90, category: "hands", description: "24/7 workflows triggered by events. Scraping. Monitoring. Processing. The system works while you sleep.", detail: "Not just on-demand anymore. Background processes running continuously.", color: "#a855f7" },
  { label: "Zapier Integrations", multiplier: 140, category: "hands", description: "Hundreds of additional services connected. Google Sheets. Webhooks. CRMs. The connector ecosystem expands.", detail: "Each new integration multiplies what the system can touch and automate.", color: "#a855f7" },
  { label: "Content Production Stack", multiplier: 220, category: "hands", description: "Gamma for presentations. ElevenLabs for voice. HaGen for video. Full content production pipeline.", detail: "Not just analysis anymore. The system produces client-ready deliverables. Agency-quality output.", color: "#a855f7" },
  { label: "Frontier Prompt Engineering", multiplier: 400, category: "frontier", description: "Techniques from the absolute best practitioners on earth. Kainos alpha. Algorithmic reasoning. Constraint architecture.", detail: "Every prompt is engineered, not typed. Patterns studied from the top 0.001% of AI users.", color: "#eab308" },
  { label: "Adversarial Red Teams", multiplier: 700, category: "frontier", description: "The system critiques its own output before it ships. Blind spots found. Bad assumptions caught. Quality assured.", detail: "Built-in skepticism. Every deliverable gets stress-tested automatically.", color: "#eab308" },
  { label: "Recursive Self-Improvement", multiplier: 1200, category: "frontier", description: "The system encodes its own failures. Every mistake makes it smarter. Improvement loops run automatically.", detail: "Session 500 is exponentially more capable than session 1. The curve is accelerating.", color: "#eab308" },
  { label: "Distilled Intelligence", multiplier: 2200, category: "frontier", description: "Every protocol reverse-engineered from the highest-performing patterns. Best GitHub repos. Best frameworks. Best of the best.", detail: "Not building from scratch. Integrating proven intelligence sources into every layer.", color: "#eab308" },
  { label: "Compound Memory (500+ Sessions)", multiplier: 4000, category: "compound", description: "Hundreds of sessions of accumulated intelligence. Every client. Every project. Every lesson. All compounding.", detail: "The system never starts from zero. 18 months of encoded judgment available instantly.", color: "#ec4899" },
  { label: "Multi-Client Deployment", multiplier: 7000, category: "compound", description: "One system, multiple businesses. Each client context loads on demand. Patterns transfer across verticals.", detail: "Mandy's health tech. Carrie's consulting. AssetMark's intelligence. All running on one OS.", color: "#ec4899" },
  { label: "The Demko Method", multiplier: 12000, category: "compound", description: "Full operating system. Always on. On demand. From a phone. Running entire business functions across multiple clients simultaneously.", detail: "One person. $20/month. 5,000x-15,000x leverage. The system is live and accelerating every day.", color: "#ffffff" }
];
const categoryLabels = { baseline: "WHERE EVERYONE IS", foundation: "POWER USER", system: "THE RED DOT (0.04%)", architecture: "SYSTEM ARCHITECTURE", hands: "THE BRAIN GETS HANDS", frontier: "FRONTIER ENGINEERING", compound: "OFF THE CHART" };
const categoryColors = { baseline: "#6b7280", foundation: "#4ade80", system: "#ef4444", architecture: "#f97316", hands: "#a855f7", frontier: "#eab308", compound: "#ec4899" };

function LeverageCurve() {
  const [currentStep, setCurrentStep] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);
  const [autoPlay, setAutoPlay] = useState(false);
  useEffect(() => { if (autoPlay && currentStep < steps.length - 1) { const t = setTimeout(() => { advance(); }, 3500); return () => clearTimeout(t); } if (autoPlay && currentStep >= steps.length - 1) { setAutoPlay(false); } }, [autoPlay, currentStep]);
  useEffect(() => { const h = (e) => { if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); advance(); } if (e.key === 'ArrowLeft') { e.preventDefault(); goBack(); } if (e.key === 'r') { reset(); } }; window.addEventListener('keydown', h); return () => window.removeEventListener('keydown', h); }, [currentStep, isAnimating]);
  const advance = () => { if (currentStep < steps.length - 1 && !isAnimating) { setIsAnimating(true); setCurrentStep(p => p + 1); setTimeout(() => setIsAnimating(false), 600); } };
  const goBack = () => { if (currentStep > 0 && !isAnimating) { setIsAnimating(true); setCurrentStep(p => p - 1); setTimeout(() => setIsAnimating(false), 400); } };
  const reset = () => { setCurrentStep(0); setAutoPlay(false); };
  const current = steps[currentStep];
  const maxM = steps[steps.length - 1].multiplier;
  const getH = (m) => { return (Math.log10(Math.max(m, 1)) / Math.log10(maxM)) * 100; };
  const fmt = (m) => m >= 1000 ? (m / 1000).toFixed(m >= 10000 ? 0 : 1) + 'K' : m + '';
  const prevCat = currentStep > 0 ? steps[currentStep - 1].category : null;
  const isNew = current.category !== prevCat;

  return React.createElement('div', { style: { background: '#0a0a0a', color: '#e5e5e5', minHeight: '100vh', fontFamily: "'Inter', -apple-system, sans-serif", display: 'flex', flexDirection: 'column', overflow: 'hidden' } },
    React.createElement('div', { style: { padding: '24px 32px 16px', borderBottom: '1px solid #1a1a1a' } },
      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '12px' } },
        React.createElement('div', null,
          React.createElement('h1', { style: { fontSize: '24px', fontWeight: 800, margin: 0, letterSpacing: '-0.5px', color: '#fff' } }, 'THE LEVERAGE CURVE'),
          React.createElement('p', { style: { fontSize: '13px', color: '#555', margin: '4px 0 0', letterSpacing: '1px' } }, 'THE DEMKO METHOD — COMPOUNDING CAPABILITY STACK')
        ),
        React.createElement('div', { style: { textAlign: 'right' } },
          React.createElement('div', { style: { fontSize: '48px', fontWeight: 800, color: current.color, lineHeight: 1, transition: 'all 0.6s ease', fontVariantNumeric: 'tabular-nums' } }, fmt(current.multiplier) + 'x'),
          React.createElement('div', { style: { fontSize: '11px', color: '#444', letterSpacing: '1.5px', textTransform: 'uppercase' } }, 'leverage multiplier')
        )
      )
    ),
    React.createElement('div', { style: { flex: 1, display: 'flex', flexDirection: 'column', padding: '20px 32px', gap: '16px', minHeight: 0 } },
      React.createElement('div', { style: { flex: 1, display: 'flex', alignItems: 'flex-end', gap: '3px', minHeight: '220px', padding: '0 0 8px', position: 'relative' } },
        React.createElement('div', { style: { position: 'absolute', left: 0, top: 0, bottom: '8px', width: '44px', display: 'flex', flexDirection: 'column', justifyContent: 'space-between', pointerEvents: 'none' } },
          ...[12000, 1000, 100, 10, 1].map(v => React.createElement('div', { key: v, style: { fontSize: '9px', color: '#333', textAlign: 'right', paddingRight: '8px', fontVariantNumeric: 'tabular-nums' } }, fmt(v) + 'x'))
        ),
        React.createElement('div', { style: { display: 'flex', alignItems: 'flex-end', gap: '3px', flex: 1, height: '100%', marginLeft: '48px' } },
          ...steps.map((s, i) => {
            const isA = i <= currentStep, isC = i === currentStep, h = isA ? getH(s.multiplier) : 0;
            return React.createElement('div', { key: i, onClick: () => { if (!isAnimating) { setIsAnimating(true); setCurrentStep(i); setTimeout(() => setIsAnimating(false), 400); } }, style: { flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'flex-end', height: '100%', cursor: 'pointer', position: 'relative' } },
              isC && React.createElement('div', { style: { position: 'absolute', top: (100 - h - 6) + '%', fontSize: '10px', fontWeight: 700, color: s.color, whiteSpace: 'nowrap', transition: 'all 0.6s ease', textShadow: '0 0 10px rgba(0,0,0,0.9)' } }, fmt(s.multiplier) + 'x'),
              React.createElement('div', { style: { width: '100%', height: h + '%', background: isA ? (isC ? 'linear-gradient(to top, ' + s.color + 'cc, ' + s.color + ')' : s.color + '44') : 'transparent', borderRadius: '3px 3px 0 0', transition: 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)', boxShadow: isC ? '0 0 24px ' + s.color + '55' : 'none', minHeight: isA ? '2px' : '0px', position: 'relative' } },
                isC && React.createElement('div', { style: { position: 'absolute', top: 0, left: 0, right: 0, height: '2px', background: s.color, boxShadow: '0 0 12px ' + s.color, borderRadius: '3px 3px 0 0' } })
              )
            );
          })
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '3px', justifyContent: 'center' } },
        ...steps.map((s, i) => React.createElement('div', { key: i, style: { width: i <= currentStep ? '18px' : '8px', height: '3px', borderRadius: '2px', background: i <= currentStep ? s.color : '#1a1a1a', transition: 'all 0.4s ease', opacity: i === currentStep ? 1 : 0.5 } }))
      ),
      React.createElement('div', { style: { background: '#111', borderRadius: '14px', padding: '24px 28px', border: '1px solid ' + current.color + '33', transition: 'border-color 0.6s ease', minHeight: '170px' } },
        isNew && React.createElement('div', { style: { fontSize: '10px', fontWeight: 700, letterSpacing: '2.5px', color: categoryColors[current.category], marginBottom: '10px', textTransform: 'uppercase' } }, categoryLabels[current.category]),
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: '16px' } },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('h2', { style: { fontSize: '22px', fontWeight: 700, color: '#fff', margin: '0 0 10px' } }, current.label),
            React.createElement('p', { style: { fontSize: '16px', color: '#bbb', margin: '0 0 12px', lineHeight: 1.55 } }, current.description),
            React.createElement('p', { style: { fontSize: '14px', color: current.color, margin: 0, fontStyle: 'italic', opacity: 0.85, transition: 'color 0.6s ease' } }, current.detail)
          ),
          React.createElement('div', { style: { fontSize: '12px', color: '#444', whiteSpace: 'nowrap', paddingTop: '4px', fontVariantNumeric: 'tabular-nums' } }, (currentStep + 1) + ' / ' + steps.length)
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '10px', justifyContent: 'center', paddingBottom: '20px', flexWrap: 'wrap' } },
        React.createElement('button', { onClick: reset, style: { background: '#1a1a1a', border: '1px solid #2a2a2a', color: '#777', padding: '12px 22px', borderRadius: '10px', fontSize: '13px', cursor: 'pointer', fontWeight: 600, fontFamily: 'inherit' } }, 'Reset'),
        React.createElement('button', { onClick: goBack, disabled: currentStep === 0, style: { background: '#1a1a1a', border: '1px solid #2a2a2a', color: currentStep === 0 ? '#2a2a2a' : '#777', padding: '12px 22px', borderRadius: '10px', fontSize: '13px', cursor: currentStep === 0 ? 'not-allowed' : 'pointer', fontWeight: 600, fontFamily: 'inherit' } }, '← Back'),
        React.createElement('button', { onClick: advance, disabled: currentStep >= steps.length - 1, style: { background: currentStep >= steps.length - 1 ? '#1a1a1a' : current.color, border: 'none', color: currentStep >= steps.length - 1 ? '#333' : '#000', padding: '12px 36px', borderRadius: '10px', fontSize: '15px', cursor: currentStep >= steps.length - 1 ? 'not-allowed' : 'pointer', fontWeight: 700, transition: 'background 0.4s ease', fontFamily: 'inherit' } }, currentStep >= steps.length - 1 ? '✓ Complete' : 'Next →'),
        React.createElement('button', { onClick: () => setAutoPlay(!autoPlay), style: { background: autoPlay ? '#333' : '#1a1a1a', border: '1px solid #2a2a2a', color: autoPlay ? '#fff' : '#777', padding: '12px 22px', borderRadius: '10px', fontSize: '13px', cursor: 'pointer', fontWeight: 600, fontFamily: 'inherit' } }, autoPlay ? '⏸ Pause' : '▶ Auto')
      ),
      React.createElement('div', { style: { textAlign: 'center', paddingBottom: '12px', fontSize: '11px', color: '#2a2a2a' } }, 'Arrow keys to navigate · Space to advance · R to reset')
    ),
    React.createElement('div', { style: { borderTop: '1px solid #111', padding: '12px 32px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
      React.createElement('span', { style: { fontSize: '11px', color: '#333' } }, '© 2026 The Demko Method'),
      React.createElement('span', { style: { fontSize: '11px', color: '#333' } }, 'demko-dashboard.pages.dev/leverage')
    )
  );
}
ReactDOM.render(React.createElement(LeverageCurve), document.getElementById('root'));
</script>
</body>
</html>